// ----------------------------------
// RSDK Project: Sonic 2
// Script Description: Death Egg Robot Object
// Script Author: Christian Whitehead/Simon Thomley
// Unpacked by Rubberduckycooly's script unpacker
// ----------------------------------

// ========================
// Aliases
// ========================

private alias object.value0  : object.timer

private alias object.value1  : object.headOffset.x
private alias object.value2  : object.headOffset.y
private alias object.value3  : object.movementCycle
private alias object.value4  : object.subState
private alias object.value5  : object.midpoint
private alias object.value6  : object.health
private alias object.value7  : object.invincibilityTimer
private alias object.value8  : object.exploding
private alias object.value9  : object.bombs // Offset used when spawning bombs

private alias object.value10 : object.flame.frame
private alias object.value11 : object.flame.timer
private alias object.value12 : object.flame.animSpeed
private alias object.value13 : object.flame.state

// Values used for the managing the following cutscene
private alias object.value14 : object.screenShake
private alias object.value15 : object.checkpoint // Offset to use for the One Way Doors checkpoints when making Sonic run away
private alias object.value16 : object.fadeValue

// States
private alias -1 : DERMAIN_STATIC
private alias  0 : DERMAIN_INIT
private alias  1 : DERMAIN_AWAITEGGMAN
private alias  2 : DERMAIN_RAISEHEAD
private alias  3 : DERMAIN_CLOSEHEAD
private alias  4 : DERMAIN_SUBPAUSE
private alias  5 : DERMAIN_RAISE
private alias  6 : DERMAIN_READYPAUSE
private alias  7 : DERMAIN_NEXTPHASE
private alias  8 : DERMAIN_WALKING
private alias  9 : DERMAIN_ASCEND // Includes being in the sky and landing, too
private alias 10 : DERMAIN_ARMSHOOT
private alias 11 : DERMAIN_EXPLODING

// The Death Egg Robot manages the ending cutscene too
private alias 12 : DERMAIN_SCREENSHAKE
private alias 13 : DERMAIN_CORRDIOREXPLODE
private alias 14 : DERMAIN_FADEOUT

// Substates used by "complete" states

// DERMAIN_WALKING substates
private alias 0 : DER_SUB_WALKING_INIT
private alias 1 : DER_SUB_WALKING_WALKAHEAD
private alias 2 : DER_SUB_WALKING_PAUSE
private alias 3 : DER_SUB_WALKING_BACKSTEP

// DERMAIN_ASCEND substates
private alias 0 : DER_SUB_ASCEND_INIT
private alias 1 : DER_SUB_ASCEND_JUMP
private alias 2 : DER_SUB_ASCEND_RISE
private alias 3 : DER_SUB_ASCEND_CREATETARGET
private alias 4 : DER_SUB_ASCEND_OFFSCREEN
private alias 5 : DER_SUB_ASCEND_FALL
private alias 6 : DER_SUB_ASCEND_LAND
private alias 7 : DER_SUB_ASCEND_BOMBPAUSE

// DERMAIN_ARMSHOOT substates
private alias 0 : DER_SUB_ARMSHOOT_INIT
private alias 1 : DER_SUB_ARMSHOOT_BENDDOWN
private alias 2 : DER_SUB_ARMSHOOT_LARMSHOT
private alias 3 : DER_SUB_ARMSHOOT_SHOOTRARM
private alias 4 : DER_SUB_ARMSHOOT_RARMSHOT
private alias 5 : DER_SUB_ARMSHOOT_GETUP

// entityPos offset aliases
// Not directly used, but here for reference
private alias  5 : DER_OFFSET_SHOULDER
private alias  4 : DER_OFFSET_FOOT_FRONT
private alias  3 : DER_OFFSET_HAND_FRONT
private alias  2 : DER_OFFSET_ARM
private alias  1 : DER_OFFSET_LEG_FRONT
private alias  0 : DER_OFFSET_DERMAIN
private alias -1 : DER_OFFSET_FOOT_BACK
private alias -2 : DER_OFFSET_HAND_BACK
private alias -3 : DER_OFFSET_LEG_BACK

// Player Aliases
private alias object.state 			: player.state
private alias object.xpos 			: player.xpos
private alias object.xvel 			: player.xvel
private alias object.speed 			: player.speed
private alias object.animation 		: player.animation
private alias object.collisionRight : player.collisionRight
private alias object.value40 		: player.hitboxLeft
private alias object.value38 		: player.hitboxTop
private alias object.value41 		: player.hitboxRight
private alias object.value39 		: player.hitboxBottom

// Shared DER appendages states
private alias 1 : BODYPART_DESTROYED
private alias 2 : BODYPART_ACTIVE

// DER Bomb Aliases
private alias object.value1 : DERBomb.originPos.y

// DER Hand Aliases
private alias object.value0 : DERHand.timer
private alias object.value1 : DERHand.originPos.y

private alias 3 : DERHAND_FIRE

// One Way Door Aliases
// (Used in cutscene)
private alias object.state : oneWayDoor.isOpen

// Game Mode Aliases
private alias 1 : MODE_SAVEGAME

// Reserved object slot Aliases
private alias 0  : SLOT_PLAYER1
private alias 25 : SLOT_MUSICEVENT_CHANGE
private alias 26 : SLOT_MUSICEVENT_BOSS

// Music Events
private alias 0 : MUSICEVENT_FADETOBOSS
private alias 2 : MUSICEVENT_TRANSITION

// Path ID Aliases
private alias 0 : PATH_A


// ========================
// Function Declarations
// ========================

reserve function DeathEggRobot_RestoreBodyParts
reserve function DeathEggRobot_CheckAnimEX
reserve function DeathEggRobot_AnimateBody
reserve function DeathEggRobot_CreateBombs


// ========================
// Tables (and lots of them!)
// ========================

// The cycle DER should follow
private table DeathEggRobot_phaseOrder
	8  // DERMAIN_WALKING
	9  // DERMAIN_ASCEND
	10 // DERMAIN_ARMSHOOT
	9  // DERMAIN_ASCEND
end table

// These DeathEggRobot_anim_* tables are root animation tables, used when calling animateBody
// The first entry in them gets replaced with a table ID, the rest of the numbers in them are animation flags

private table DeathEggRobot_anim_bendDown
	0 // DeathEggRobot_anim_sub_bend gets placed here
	0, 1, 2, 3, -1, 0
end table

private table DeathEggRobot_anim_getUp
	0 // DeathEggRobot_anim_sub_bend gets placed here
	5, 6, 7, 8, -1, 0
end table

private table DeathEggRobot_anim_land
	0 // DeathEggRobot_anim_sub_bend gets placed here
	0, 1, 2, 3, 4, 5, 6, 7, 8, 192
end table

// This is the anim sub-table used for the above proper anim tables
// (confusing system, I know)
private table DeathEggRobot_anim_sub_bend[9]


private table DeathEggRobot_anim_jump
	0 // DeathEggRobot_anim_sub_jump gets placed here
	0, 1, 2, 192
end table


// Also an anim sub-table
private table DeathEggRobot_anim_sub_jump[3]


private table DeathEggRobot_anim_stepAhead
	0 // DeathEggRobot_anim_sub_walk gets placed here
	0, 1, 2, 3, 64, 4, 5, 6, 7, 8, 64, 9, 10, 1, 2, 3, 64, 4, 5, 6, 7, 8, 64, 192
end table


private table DeathEggRobot_anim_stepBack
	0 // DeathEggRobot_anim_sub_walk gets placed here
	136, 135, 134, 133, 11, 64, 192
end table


// The last anim sub-table, also placed in a weird spot
private table DeathEggRobot_anim_sub_walk[12]


// All the way over here for some reason, this frame was likely added after the entire object had already been completed
private table DeathEggRobot_bend_frame_5
	0
	8
	0, 0, 0
end table

// Similar story here to the above
private table DeathEggRobot_jump_frame_2
	0
	16
	0, 0, 0
end table

// Holds the base positions of all DER body parts
// Format of the table:
//  - First number is how many "entries" there are
// Then each entry consists of
//   -> Object entity pos (relative to the current Death Egg Robot object)
//   -> X offset (from this object's pos, will automatically get flipped when facing the other way)
//   -> Y offset (from this object's pos)
private table DeathEggRobot_bodyPartsOrigin
	 6
	 4, -0x40000,  0x3C0000
	 3, -0xC0000,  0x080000
	 2,	 0xC0000, -0x080000
	 1,  0x40000,  0x240000
	-1, -0x40000,  0x3C0000
	-2, -0xC0000,  0x080000
	-3,  0x40000,  0x240000
end table


// All these remaining DeathEggRobot_*_frame_* tables are individual animation entries
// The format they follow is pretty similar to the above
//  - First number is how many "entries" in the table there are (not counting the next number)
//  - Second number is the delay for this frame in the animation
// Then, the rest of the table is individual component entries, each entry comprised of 3 numbers
// All offsets are relative to the main DER object
//  - First number is the offset (entityPos-wise) for the target component
//  - Second number is X offset for the component to move
//  - Third number is the Y offset

// These first few are for the animations in which the DER bends down, like when jumping or shooting arms

private table DeathEggRobot_bend_frame_1
	 5
	 8
	 0, -0x2000,  0x0C00
	 3, -0x2000,  0x0C00
	 2,	-0x2000,  0x0C00
	-2, -0x2000,  0x0C00
	 1, -0x0800,  0x0400
	-3, -0x0800,  0x0400
end table

private table DeathEggRobot_bend_frame_2
	 5
	 8
	 0, -0x1400,  0x1400
	 3, -0x1400,  0x1400
	 2, -0x1400,  0x1400
	-2, -0x1400,  0x1400
	 1, -0x0600,  0x0600
	-3, -0x0600,  0x0600
end table

private table DeathEggRobot_bend_frame_3
	 5
	 8
	 0, -0x0800,  0x1400
	 3, -0x0800,  0x1400
	 2, -0x0800,  0x1400
	-2, -0x0800,  0x1400
	 1, -0x0200,  0x0400
	-3, -0x0200,  0x0400
end table

private table DeathEggRobot_bend_frame_4
	 5
	 8
	 0, -0x0400,  0x0C00
	 3, -0x0400,  0x0C00
	 2, -0x0400,  0x0C00
	-2, -0x0400,  0x0C00
	 1,  0x0000,  0x0200
	-3,  0x0000,  0x0200
end table

// frame5 is all the way at the top, separate from these for some reason
// Perhaps it was added late in dev or something

private table DeathEggRobot_bend_frame_6
	 5
	 8
	 0, 0x0400, -0x1800
	 3, 0x0400, -0x1800
	 2, 0x0400, -0x1800
	-2, 0x0400, -0x1800
	 1, 0x0200, -0x0600
	-3, 0x0200, -0x0600
end table

private table DeathEggRobot_bend_frame_7
	 5
	 8
	 0, 0x0C00, -0x1800
	 3, 0x0C00, -0x1800
	 2, 0x0C00, -0x1800
	-2, 0x0C00, -0x1800
	 1, 0x0400, -0x0400
	-3, 0x0400, -0x0400
end table

private table DeathEggRobot_bend_frame_8
	 5
	 8
	 0, 0x1800, -0x0C00
	 3, 0x1800, -0x0C00
	 2, 0x1800, -0x0C00
	-2, 0x1800, -0x0C00
	 1, 0x0400, -0x0400
	-3, 0x0400, -0x0400
end table

private table DeathEggRobot_bend_frame_9
	 5
	 8
	 0, 0x1800, -0x0400
	 3, 0x1800, -0x0400
	 2, 0x1800, -0x0400
	-2, 0x1800, -0x0400
	 1, 0x0600, -0x0200
	-3, 0x0600, -0x0200
end table

// These next couple of tables are frames for the jumping animation

private table DeathEggRobot_jump_frame_1
	 5
	 16
	 0, 0x0000, 0x0400
	 3, 0x0000, 0x0400
	 2, 0x0000, 0x0400
	-2, 0x0000, 0x0400
	 1, 0x0000, 0x0400
	-3, 0x0000, 0x0400
end table

// frame2 is all the way near the end of the list, it seems it was added in post after everything else was done

private table DeathEggRobot_jump_frame_3
	 5
	 8
	 0, 0x0000, -0x0800
	 3, 0x0000, -0x0800
	 2, 0x0000, -0x0800
	-2, 0x0000, -0x0800
	 1, 0x0000, -0x0800
	-3, 0x0000, -0x0800
end table

// And finally, these last tables are frames for the walking animation

private table DeathEggRobot_walk_frame_1
	 6
	 32
	 1, -0x0800, -0x0800
	 4, -0x0800, -0x0800
	 0,  0x0000, -0x0400
	 3,  0x0400, -0x0500
	 2,  0x0300, -0x0500
	-2, -0x0400, -0x0500
	-3,  0x0000, -0x0200
end table

private table DeathEggRobot_walk_frame_2
	 6
	 16
	 1, -0x1000, -0x0400
	 4, -0x1000, -0x0400
	 0, -0x1000, -0x0400
	 3, -0x0C00, -0x0500
	 2, -0x0D00, -0x0500
	-2, -0x1400, -0x0500
	-3, -0x0800,  0x0000
end table

private table DeathEggRobot_walk_frame_3
	 5
	 16
	 1, -0x0800,  0x0400
	 4, -0x0800,  0x0400
	 0, -0x0800,  0x0400
	 3, -0x0400,  0x0300
	 2, -0x0500,  0x0300
	-2, -0x0C00,  0x0300
end table

private table DeathEggRobot_walk_frame_4
	 6
	 16
	 1, -0x0400, 0x1000
	 4, -0x0800, 0x1000
	 0,  0x0000, 0x0800
	 3, -0x0800, 0x0A00
	 2, -0x0600, 0x0A00
	-2,  0x0800, 0x0A00
	-3,  0x0000, 0x0800
end table

private table DeathEggRobot_walk_frame_5
	 6
	 32
	 1, -0x0200, -0x0200
	 0, -0x0C00, -0x0400
	 3, -0x1000, -0x0300
	 2, -0x0F00, -0x0300
	-2, -0x0800, -0x0300
	-3, -0x1400, -0x0600
	-1, -0x1800, -0x0400
end table

private table DeathEggRobot_walk_frame_6
	 4
	 32
	-3, -0x0800, -0x0400
	-1, -0x0800, -0x0400
	 3, -0x0400, -0x0100
	 2, -0x0300, -0x0100
	-2,  0x0400, -0x0100
end table

private table DeathEggRobot_walk_frame_7
	 6
	 16
	-3, -0x1000, -0x0400
	-1, -0x1000, -0x0400
	 0, -0x1000, -0x0400
	 3, -0x1400, -0x0500
	 2, -0x1300, -0x0500
	-2, -0x0C00, -0x0500
	 1, -0x0800,  0x0000
end table

private table DeathEggRobot_walk_frame_8
	 5
	 16
	-3, -0x0800, 0x0400
	-1, -0x0800, 0x0400
	 0, -0x0800, 0x0400
	 3, -0x0C00, 0x0300
	 2, -0x0B00, 0x0300
	-2, -0x0400, 0x0300
end table

private table DeathEggRobot_walk_frame_9
	 6
	 16
	-3, -0x0400, 0x1000
	-1, -0x0800, 0x1000
	 0, 0x0000, 0x0800
	 3, 0x0800, 0x0A00
	 2, 0x0600, 0x0A00
	-2, -0x0800, 0x0A00
	 1, 0x0000, 0x0800
end table

private table DeathEggRobot_walk_frame_10
	 6
	 32
	-3, -0x0200, -0x0200
	 0, -0x0C00, -0x0400
	 3, -0x0800, -0x0300
	 2, -0x0900, -0x0300
	-2, -0x0F00, -0x0300
	 1, -0x1400, -0x0600
	 4, -0x1800, -0x0400
end table

private table DeathEggRobot_walk_frame_11
	 4
	 32
	 1, -0x0800, -0x0600
	 4, -0x0800, -0x0400
	 3,  0x0400, -0x0100
	 2,  0x0300, -0x0100
	-2, -0x0400, -0x0100
end table

private table DeathEggRobot_walk_frame_12
	 6
	 16
	-3, 0x0000,  0x0800
	-1, 0x0000,  0x0800
	 0, 0x0000,  0x0800
	 3, 0x0000,  0x0800
	 2, 0x0000,  0x0800
	-2, 0x0000,  0x0800
	 1, 0x0000,  0x0800
end table


// And now, finally, the actual code starts!

// ========================
// Function Definitions
// ========================

private function DeathEggRobot_RestoreBodyParts
	// Restores all the body parts back to their normal positions, used for cleanup quite often
	
	// Preconditions:
	// - temp0 is set to the table ID of a DER body part table (always DeathEggRobot_bodyPartsOrigin)
	
	temp7 = 0
	
	// First, get entry count
	GetTableValue(temp6, temp7, temp0)
	temp7++
	while temp6 >= 0
		
		// Get the object's entity pos offset
		GetTableValue(temp1, temp7, temp0)
		temp7++
		arrayPos0 = object.entityPos
		arrayPos0 += temp1
		
		// Object xpos offset
		GetTableValue(temp1, temp7, temp0)
		temp7++
		
		// Object ypos offset
		GetTableValue(temp2, temp7, temp0)
		temp7++
		
		// Update xpos
		object[arrayPos0].xpos = object.xpos
		if object.direction == FLIP_NONE
			object[arrayPos0].xpos += temp1
		else
			object[arrayPos0].xpos -= temp1
		end if
		
		// Update ypos
		object[arrayPos0].ypos = object.ypos
		object[arrayPos0].ypos += temp2

		temp6--
	loop
end function


private function DeathEggRobot_CheckAnimEX
	temp7 = true
	while temp7 == true
		temp7 = false
		temp0 &= 63
		temp1 >>= 6
		switch temp1
		case 1
			// Used when the legs are moving
			if object.animationTimer == 0
				object.frame++
				PlaySfx(SfxName[Crusher], false)
				GetTableValue(temp0, object.frame, temp6)
				temp1 = temp0
				temp1 &= 192
				if temp1 != 0
					temp7 = true
				end if
			end if
			break

		case 2
			// Flip flag
			temp4 = true
			break

		case 3
			// Stop the object from animating (for this frame, at least)
			object.frame = 1
			checkResult = true
			break

		end switch
	loop
end function


private function DeathEggRobot_AnimateBody
	// Preconditions:
	// - When this function is called, temp6 is holding an animation table
	//   This table is, itself, holding another table, where that table being held also contains a long string of tables
	//   Far too many tables to wrap your head around, to say the least...
	
	// Essentially, what this function itself does is move and animate the body
	
	GetTableValue(temp5, 0, temp6)
	
	GetTableValue(temp0, object.frame, temp6)
	temp1 = temp0
	temp4 = false
	temp1 &= 192
	
	checkResult = false
	if temp0 != 0
		CallFunction(DeathEggRobot_CheckAnimEX)
	end if
	
	if checkResult == false
		GetTableValue(temp2, temp0, temp5)
		temp7 = 0
		GetTableValue(temp0, temp7, temp2)
		temp7++
		GetTableValue(temp3, temp7, temp2)
		temp7++
		object.animationTimer++
		if object.animationTimer >= temp3
			object.animationTimer = 0
			object.frame++
		end if
		
		while temp0 >= 0
			GetTableValue(temp5, temp7, temp2)
			temp7++
			arrayPos0 = object.entityPos
			arrayPos0 += temp5
			GetTableValue(temp1, temp7, temp2)
			temp7++
			temp1 <<= 4
			if object.direction == FLIP_NONE
				if temp4 == false
					object[arrayPos0].xpos += temp1
				else
					object[arrayPos0].xpos -= temp1
				end if
			else
				if temp4 == false
					object[arrayPos0].xpos -= temp1
				else
					object[arrayPos0].xpos += temp1
				end if
			end if
			GetTableValue(temp1, temp7, temp2)
			temp7++
			temp1 <<= 4
			if temp4 == false
				object[arrayPos0].ypos += temp1
			else
				object[arrayPos0].ypos -= temp1
			end if
			temp0--
		loop
	end if
end function


private function DeathEggRobot_CreateBombs
	arrayPos0 = object[-7].entityPos
	
	// Offset the entity pos based on the last bombs used, in case there's more than one pair active
	arrayPos0 += object.bombs
	
	// Update the value with a cap of 3, there should only ever be 4 bombs (2 pairs) max active at one point
	object.bombs += 2
	object.bombs &= 3
	
	// Create bomb 1
	object[arrayPos0].type = TypeName[DER Bomb]
	object[arrayPos0].xpos = object.xpos
	if object.direction == FLIP_NONE
		object[arrayPos0].xpos += 0x380000
		object[arrayPos0].xvel = 0x6000
	else
		object[arrayPos0].xpos -= 0x380000
		object[arrayPos0].xvel = -0x6000
	end if
	object[arrayPos0].ypos = object.ypos
	object[arrayPos0].ypos -= 0x140000
	object[arrayPos0].yvel = -0x80000
	DERBomb[arrayPos0].originPos.y = object[arrayPos0].ypos
	object[arrayPos0].priority = PRIORITY_ACTIVE

	arrayPos0++

	// And now create bomb 2
	object[arrayPos0].type = TypeName[DER Bomb]
	object[arrayPos0].xpos = object.xpos
	if object.direction == FLIP_NONE
		object[arrayPos0].xpos += 0x380000
		object[arrayPos0].xvel = 0xC000
	else
		object[arrayPos0].xpos -= 0x380000
		object[arrayPos0].xvel = -0xC000
	end if
	object[arrayPos0].ypos = object.ypos
	object[arrayPos0].ypos -= 0x140000
	object[arrayPos0].yvel = -0xA0000
	DERBomb[arrayPos0].originPos.y = object[arrayPos0].ypos
	object[arrayPos0].priority = PRIORITY_ACTIVE
end function


// ========================
// Events
// ========================

event ObjectUpdate
	switch object.state
	case DERMAIN_INIT
		temp0 = stage.curYBoundary2
		temp0 -= screen.ysize
		stage.newYBoundary1 = temp0

		temp0 = object.xpos
		temp0 >>= 16
		temp0 += 68
		stage.newXBoundary2 = temp0

		temp0 -= 0x200
		stage.newXBoundary1 = temp0
		object.priority = PRIORITY_ACTIVE

		// Setup all the body parts
		// - Order is important, as it also controls the order the sprites should be drawn
		// - Back-most appendages are behind this object in entityPos, frontwise are, well, in-front in terms of both draw order and entityPos too

		object[+5].type = TypeName[DER Shoulder]
		object[+5].priority = PRIORITY_ACTIVE

		// Front foot
		object[+4].type = TypeName[DER Foot]
		object[+4].priority = PRIORITY_ACTIVE

		// Front hand
		object[+3].type = TypeName[DER Hand]
		object[+3].priority = PRIORITY_ACTIVE

		object[+2].type = TypeName[DER Arm]
		object[+2].priority = PRIORITY_ACTIVE

		// Front leg
		object[+1].type = TypeName[DER Leg]
		object[+1].priority = PRIORITY_ACTIVE

		// Back foot
		object[-1].type = TypeName[DER Foot]
		object[-1].priority = PRIORITY_ACTIVE

		// Back hand
		object[-2].type = TypeName[DER Hand]
		object[-2].priority = PRIORITY_ACTIVE

		// Back leg
		object[-3].type = TypeName[DER Leg]
		object[-3].priority = PRIORITY_ACTIVE

		object.midpoint = object.xpos
		object.midpoint -= 0xC00000

#platform: USE_STANDALONE
		object.health = 12
#endplatform
#platform: USE_ORIGINS
		if game.bossOneLife == false
			object.health = 12
		else
			object.health = 1
		end if
#endplatform
		
		temp0 = DeathEggRobot_bodyPartsOrigin
		CallFunction(DeathEggRobot_RestoreBodyParts)
		object.frame = 1
		object.flame.frame = 5
		SetMusicTrack("FinalBoss.ogg", 4, true)
		object.state = DERMAIN_AWAITEGGMAN
		break

	case DERMAIN_AWAITEGGMAN
		break

	case DERMAIN_RAISEHEAD
		object.headOffset.y -= 0x10000
		if object.headOffset.y <= -0x240000
			object.state = DERMAIN_CLOSEHEAD
		end if
		break

	case DERMAIN_CLOSEHEAD
		object.headOffset.x -= 0x7800
		object.rotation -= 4
		if object.rotation <= 0
			object.state = DERMAIN_SUBPAUSE
		end if
		break

	case DERMAIN_SUBPAUSE
		object.timer++
		if object.timer == 112
			vs.bossAttack = false
			ResetObjectEntity(SLOT_MUSICEVENT_BOSS, TypeName[Music Event], MUSICEVENT_FADETOBOSS, 0, 0)
			object[SLOT_MUSICEVENT_BOSS].priority = PRIORITY_ACTIVE
		end if

		if object.timer == 180
			object.timer = 0
			PlaySfx(SfxName[Large Wall], false)
			object.flame.frame = 5
			object.flame.animSpeed = 4
			object.flame.state = 1
			object.state = DERMAIN_RAISE
		end if
		break

	case DERMAIN_RAISE
		object.ypos -= 0x10000
		object.timer++
		if object.timer == 30
			PlaySfx(SfxName[Large Wall], false)
		end if

		if object.timer == 120
			object.timer = 0

			// Tell the rest of the body to get ready
			object[+5].state = BODYPART_ACTIVE
			object[+4].state = BODYPART_ACTIVE
			object[+3].state = BODYPART_ACTIVE
			object[+2].state = BODYPART_ACTIVE
			object[+1].state = BODYPART_ACTIVE
			object[-1].state = BODYPART_ACTIVE
			object[-2].state = BODYPART_ACTIVE
			object[-3].state = BODYPART_ACTIVE

			object.flame.state = 2
			object.state = DERMAIN_READYPAUSE
		end if

		temp0 = DeathEggRobot_bodyPartsOrigin
		CallFunction(DeathEggRobot_RestoreBodyParts)
		break

	case DERMAIN_READYPAUSE
		object.timer++
		if object.timer == 32
			object.timer = 0
			object.state = DERMAIN_NEXTPHASE
		end if
		break

	case DERMAIN_NEXTPHASE
		object.timer = 32
		object.subState = 0
		GetTableValue(object.state, object.movementCycle, DeathEggRobot_phaseOrder)
		if object.state == DERMAIN_ASCEND
			object.flame.frame = 5
			object.flame.animSpeed = 16
			object.flame.state = 1
		end if
		object.movementCycle++
		object.movementCycle &= 3
		break

	case DERMAIN_WALKING
		switch object.subState
		case DER_SUB_WALKING_INIT
			object.timer--
			if object.timer < 0
				object.subState = DER_SUB_WALKING_WALKAHEAD
			end if
			break

		case DER_SUB_WALKING_WALKAHEAD
			temp6 = DeathEggRobot_anim_stepAhead
			CallFunction(DeathEggRobot_AnimateBody)
			if checkResult == true
				object.timer = 64
				object.subState = DER_SUB_WALKING_PAUSE
			end if
			break

		case DER_SUB_WALKING_PAUSE
			object.timer--
			if object.timer < 0
				object.subState = DER_SUB_WALKING_BACKSTEP
			end if
			break

		case DER_SUB_WALKING_BACKSTEP
			temp6 = DeathEggRobot_anim_stepBack
			CallFunction(DeathEggRobot_AnimateBody)
			if checkResult == true
				object.timer = 64
				object.state = DERMAIN_NEXTPHASE
			end if
			break

		end switch
		break

	case DERMAIN_ASCEND
		switch object.subState
		case DER_SUB_ASCEND_INIT
			object.timer--
			if object.timer < 0
				object.subState = DER_SUB_ASCEND_JUMP
			end if
			break

		case DER_SUB_ASCEND_JUMP
			temp6 = DeathEggRobot_anim_jump
			CallFunction(DeathEggRobot_AnimateBody)
			if checkResult == true
				object.timer = 128
				PlaySfx(SfxName[Thruster], false)
				object.subState = DER_SUB_ASCEND_RISE
			end if
			break

		case DER_SUB_ASCEND_RISE
			object.timer--
			if object.timer < 0
				object.subState = DER_SUB_ASCEND_CREATETARGET
			else
				object.ypos -= 0x20000
				temp0 = oscillation
				temp0 &= 31
				if temp0 == 0
					PlaySfx(SfxName[Thruster], false)
				end if
				temp0 = DeathEggRobot_bodyPartsOrigin
				CallFunction(DeathEggRobot_RestoreBodyParts)
			end if
			break

		case DER_SUB_ASCEND_CREATETARGET
			// Because the timer isn't reset between this and the previous substate, this state only lasts for a single frame
			object.timer--
			if object.timer < 0
				object.timer = 0
				object.subState = DER_SUB_ASCEND_OFFSCREEN
				object[+6].type = TypeName[DER Target]
				object[+6].xpos = object[SLOT_PLAYER1].xpos
				object[+6].ypos = object[SLOT_PLAYER1].ypos
			end if
			break

		case DER_SUB_ASCEND_OFFSCREEN
			if object.timer != 0
				if object.xpos < object.midpoint
					object.direction = FLIP_X
				else
					object.direction = FLIP_NONE
				end if

				object[+5].direction = object.direction
				object[+4].direction = object.direction
				object[+3].direction = object.direction
				object[+2].direction = object.direction
				object[+1].direction = object.direction
				object[-1].direction = object.direction
				object[-2].direction = object.direction
				object[-3].direction = object.direction

				object.timer = 32
				temp0 = DeathEggRobot_bodyPartsOrigin
				CallFunction(DeathEggRobot_RestoreBodyParts)
				object.subState = DER_SUB_ASCEND_FALL
			end if
			break

		case DER_SUB_ASCEND_FALL
			object.timer--
			if object.timer < 0
				object.timer = 64
				PlaySfx(SfxName[Ledge Break], false)
				object.screenShake = 64
				object.flame.state = 2
				object.subState = DER_SUB_ASCEND_LAND
			else
				object.ypos += 0x80000
				temp0 = DeathEggRobot_bodyPartsOrigin
				CallFunction(DeathEggRobot_RestoreBodyParts)
			end if
			break

		case DER_SUB_ASCEND_LAND
			temp6 = DeathEggRobot_anim_land
			CallFunction(DeathEggRobot_AnimateBody)
			if checkResult == true
				temp0 = DeathEggRobot_bodyPartsOrigin
				CallFunction(DeathEggRobot_RestoreBodyParts)

				temp0 = false

				if object.direction == FLIP_NONE
					if object[SLOT_PLAYER1].xpos > object.xpos
						temp0 = true
					end if
				else
					if object[SLOT_PLAYER1].xpos < object.xpos
						temp0 = true
					end if
				end if

				if temp0 == false
					object.state = DERMAIN_NEXTPHASE
				else
					object.timer = 96
					object.subState = DER_SUB_ASCEND_BOMBPAUSE
					CallFunction(DeathEggRobot_CreateBombs)
				end if
			end if
			break

		case DER_SUB_ASCEND_BOMBPAUSE
			object.timer--
			if object.timer < 0
				object.state = DERMAIN_NEXTPHASE
			end if
			break

		end switch
		break

	case DERMAIN_ARMSHOOT
		switch object.subState
		case DER_SUB_ARMSHOOT_INIT
			object.timer--
			if object.timer < 0
				object.subState = DER_SUB_ARMSHOOT_BENDDOWN
			end if
			break

		case DER_SUB_ARMSHOOT_BENDDOWN
			temp6 = DeathEggRobot_anim_bendDown
			CallFunction(DeathEggRobot_AnimateBody)
			if checkResult == true
				temp0 = false
				if object.direction == FLIP_NONE
					if object[SLOT_PLAYER1].xpos > object.xpos
						temp0 = true
					end if
				else
					if object[SLOT_PLAYER1].xpos < object.xpos
						temp0 = true
					end if
				end if

				if temp0 == false
					object.timer = 64
					object[+3].state = DERHAND_FIRE
					DERHand[+3].timer = 16
					DERHand[+3].originPos.y = object[+3].ypos
					object.subState = DER_SUB_ARMSHOOT_LARMSHOT
				else
					object.timer = 32
					object.subState = DER_SUB_ARMSHOOT_RARMSHOT
					CallFunction(DeathEggRobot_CreateBombs)
				end if
			end if
			break

		case DER_SUB_ARMSHOOT_LARMSHOT
			object.timer--
			if object.timer < 0
				object.subState = DER_SUB_ARMSHOOT_SHOOTRARM
			end if
			break

		case DER_SUB_ARMSHOOT_SHOOTRARM
			object.timer--
			if object.timer < 0
				object.timer = 64
				object[-2].state = DERHAND_FIRE
				DERHand[-2].timer = 16
				DERHand[-2].originPos.y = object[-2].ypos
				object.subState = DER_SUB_ARMSHOOT_RARMSHOT
			end if
			break

		case DER_SUB_ARMSHOOT_RARMSHOT
			object.timer--
			if object.timer < 0
				object.subState = DER_SUB_ARMSHOOT_GETUP
			end if
			break

		case DER_SUB_ARMSHOOT_GETUP
			temp6 = DeathEggRobot_anim_getUp
			CallFunction(DeathEggRobot_AnimateBody)
			if checkResult == true
				object.state = DERMAIN_NEXTPHASE
			end if
			break

		end switch
		break

	case DERMAIN_EXPLODING
		object.timer++
		if object.timer == 120
			object.timer = 0
			object.exploding = false
			object.state++
			options.touchControls = false
			object[SLOT_PLAYER1].controlMode = CONTROLMODE_NONE
			object[SLOT_PLAYER1].jumpPress   = false
			object[SLOT_PLAYER1].jumpHold    = false
			object[SLOT_PLAYER1].up          = false
			object[SLOT_PLAYER1].down        = false
			object[SLOT_PLAYER1].left        = false
			object[SLOT_PLAYER1].right       = true
			stage.deathBoundary = 0x7FFF0000
			temp0 = tileLayer[0].xsize
			temp0 <<= 7
			stage.newXBoundary2 = temp0
		end if

		object.ypos += object.yvel
		object.yvel += 0x3800
		ObjectTileCollision(CSIDE_FLOOR, 0, 36, PATH_A)
		if checkResult == true
			object.yvel >>= 2
			FlipSign(object.yvel)
			if object.yvel > -0x10000
				object.yvel = 0
			end if
		end if
		break

	case DERMAIN_SCREENSHAKE
		object.timer++
		if object.timer == 30
			object.screenShake = 0xFFFF
		end if

		temp0 = object.screenShake
		temp0 %= 40
		if temp0 == 8
			PlaySfx(SfxName[Rumble], false)
		end if

		object[SLOT_PLAYER1].right = true
		if object[SLOT_PLAYER1].xpos > object[+7].xpos
			object.timer = -15
			object.state = DERMAIN_CORRDIOREXPLODE
			if object.screenShake == 0
				object.screenShake = 0xFFFF
			end if
		end if

		temp0 = object.checkpoint
		arrayPos0 = object[+8].entityPos
		arrayPos0 += object.checkpoint
		temp1 = object[arrayPos0].xpos
		if object[SLOT_PLAYER1].xpos > temp1
			object.checkpoint++
			temp0++
			arrayPos0++
		end if
		
		while temp0 < 7
			oneWayDoor[arrayPos0].isOpen = true
			arrayPos0++
			temp0++
		end if
		break

	case DERMAIN_CORRDIOREXPLODE
		temp0 = object.screenShake
		temp0 %= 40
		if temp0 == 8
			PlaySfx(SfxName[Rumble], false)
		end if
		Rand(temp0, 96)
		temp0 -= 48
		temp0 <<= 16
		temp0 += object[SLOT_PLAYER1].xpos
		temp0 -= 0x400000
		Rand(temp1, 96)
		temp1 -= 48
		temp1 <<= 16
		temp1 += object[SLOT_PLAYER1].ypos
		CreateTempObject(TypeName[Explosion], 0, temp0, temp1)
		object[tempObjectPos].drawOrder = 5
		temp0 = oscillation
		temp0 &= 3
		if temp0 == 0
			PlaySfx(SfxName[Explosion], false)
		end if
		object.timer++
		
		// Death Egg Robots with Property Values of 0 should trigger the ending cutscene after defeat
		if object.propertyValue == 0
			switch object.timer
			case 120
			case 180
			case 240
				PlaySfx(SfxName[Large Explosion], false)
				break

			case 270
#platform: USE_ORIGINS
				CallNativeFunction2(NotifyCallback, NOTIFY_BOSS_END, true)
#endplatform
				object.state = DERMAIN_FADEOUT
				break

			end switch
		else
			if object.timer > 140
				PlaySfx(SfxName[Large Explosion], false)
				ResetObjectEntity(object.entityPos, TypeName[Blank Object], 0, 0, 0)
			end if
		end if

		object[SLOT_PLAYER1].right = true

		temp0 = object.checkpoint
		arrayPos0 = object[+8].entityPos
		arrayPos0 += object.checkpoint
		temp1 = object[arrayPos0].xpos
		if object[SLOT_PLAYER1].xpos > temp1
			object.checkpoint++
			temp0++
			arrayPos0++
		end if

		while temp0 < 7
			oneWayDoor[arrayPos0].isOpen = true
			arrayPos0++
			temp0++
		end if
		
		// [Fallthrough]
	case DERMAIN_FADEOUT
		if object.timer >= 120
			music.volume--
			object.fadeValue += 2
			
			// The fade value is updated regardless of if the Death Egg Robot should trigger the cutscene or not, it's just that the actual fade isn't applied if it doesn't need to be
			if object.propertyValue == 0
				SetScreenFade(255, 255, 255, object.fadeValue)
			end if

			if object.fadeValue >= 0x300
#platform: USE_ORIGINS
				if game.playMode != BOOT_PLAYMODE_BOSSRUSH
					temp0 = StageStatsUsabilityParam5
					temp0 &= 1
					temp1 = StageStatsUsabilityParam5
					temp1 &= 2
					temp2 = StageStatsUsabilityParam5
					temp2 &= 4
					CallNativeFunction4(NotifyCallback, NOTIFY_STATS_CHARA_ACTION, temp0, temp1, temp2)
					stage.timeEnabled = false
					CallNativeFunction2(NotifyCallback, NOTIFY_ACT_FINISH, 0)
					StageStatsUsabilityParam1 = 0
					StageStatsUsabilityParam2 = 0
					StageStatsUsabilityParam3 = 0
					StageStatsUsabilityParam4 = 0
					StageStatsUsabilityParam5 = 0
					StatsUsabilityParam1 = 0
					StatsUsabilityParam2 = 0
					StatsUsabilityParam3 = 0
					StatsUsabilityParam4 = 0
					StatsUsabilityParam5 = 0
#endplatform

					if stage.debugMode == false
						if options.stageSelectFlag == false
							CallNativeFunction2(SetLeaderboard, 22, player.score)
						end if
					end if

					if options.gameMode == MODE_SAVEGAME
						// Mark the current save as a completed one
						arrayPos1 = options.saveSlot
						arrayPos1 <<= 3
						arrayPos1 += 4
						saveRAM[arrayPos1] = 22
						WriteSaveRAM()
					end if

#platform: USE_ORIGINS
					// This is already done earlier in DERMAIN_CORRDIOREXPLODE... but may as well do it again for good measure?
					CallNativeFunction2(NotifyCallback, NOTIFY_BOSS_END, true)
					
					if game.oneStageFlag == false
#endplatform
						// Start the Ending proper
						stage.activeList = PRESENTATION_STAGE
						stage.listPos = 1
						LoadStage()
#platform: USE_ORIGINS
					else
						game.callbackResult = -1
						CallNativeFunction4(NotifyCallback, NOTIFY_STAGE_RETRY, 1, stage.listPos, 0)
						object.state = DERMAIN_STATIC
					end if
				end if
#endplatform
			end if
		end if
		break

	end switch

	if object.state > DERMAIN_RAISE
		if object.health != 0
			if object.invincibilityTimer > 0
				object.invincibilityTimer--
				GetBit(temp0, object.invincibilityTimer, 0)
				if temp0 == true
					SetPaletteEntry(0, 192, 0xE0E0E0)
				else
					SetPaletteEntry(0, 192, 0x000000)
				end if
			end if

			foreach (GROUP_PLAYERS, currentPlayer, ACTIVE_ENTITIES)
				if object.invincibilityTimer == 0
					BoxCollisionTest(C_TOUCH, object.entityPos, -32, -60, 32, 32, currentPlayer, player[currentPlayer].hitboxLeft, player[currentPlayer].hitboxTop, player[currentPlayer].hitboxRight, player[currentPlayer].hitboxBottom)

					if checkResult == true
						CallFunction(Player_CheckHit)

						if checkResult == true
							object.health--

							if object.health == 0
#platform: USE_ORIGINS
								CallNativeFunction2(NotifyCallback, NOTIFY_KILL_BOSS, 0)
#endplatform

								player.score += 1000
								object.exploding = true
								object.state = DERMAIN_EXPLODING
								object.timer = 0

								// Make all the body parts fall off

								// Shoulder
								object[+5].state = BODYPART_DESTROYED
								object[+5].xvel = 0x20000
								object[+5].yvel = -0x40000

								// Front foot
								object[+4].state = BODYPART_DESTROYED
								object[+4].xvel = -0x10000
								object[+4].yvel = -0x10000

								// Front hand
								object[+3].state = BODYPART_DESTROYED
								object[+3].xvel = 0x30000
								object[+3].yvel = -0x30000

								// Front arm
								object[+2].state = BODYPART_DESTROYED
								object[+2].xvel = -0x10000
								object[+2].yvel = -0x40000

								// Front leg
								object[+1].state = BODYPART_DESTROYED
								object[+1].xvel = 0x18000
								object[+1].yvel = -0x20000

								// Back foot
								object[-1].state = BODYPART_DESTROYED
								object[-1].xvel = -0x20000
								object[-1].yvel = -0x30000

								// Back hand
								object[-2].state = BODYPART_DESTROYED
								object[-2].xvel = 0
								object[-2].yvel = -0x40000

								// Back leg
								object[-3].state = BODYPART_DESTROYED
								object[-3].xvel = 0x10000
								object[-3].yvel = -0x30000

								object.flame.state = 3
							else
								object.invincibilityTimer = 60
								PlaySfx(SfxName[Boss Hit], false)
							end if
						end if
					else
						if object.direction == FLIP_NONE
							BoxCollisionTest(C_TOUCH, object.entityPos, 48, 16, 64, 32, currentPlayer, C_BOX, C_BOX, C_BOX, C_BOX)
						else
							BoxCollisionTest(C_TOUCH, object.entityPos, -64, 16, -48, 32, currentPlayer, C_BOX, C_BOX, C_BOX, C_BOX)
						end if

						if checkResult == true
							CallFunction(Player_FireHit)
						end if
					end if
				end if
			next
		end if
	end if

	if object.state <= DERMAIN_EXPLODING
		foreach (GROUP_PLAYERS, currentPlayer, ACTIVE_ENTITIES)
			temp0 = player[currentPlayer].collisionRight
			temp0 <<= 16
			temp0 += player[currentPlayer].xpos
			temp1 = stage.curXBoundary2
			temp1 <<= 16
			if temp0 > temp1
				player[currentPlayer].xvel = 0
				player[currentPlayer].speed = 0
				player[currentPlayer].xpos = temp1
				temp0 = player[currentPlayer].collisionRight
				temp0 <<= 16
				player[currentPlayer].xpos -= temp0
			end if
		next
	end if

	if object.exploding == true
		temp0 = oscillation
		temp0 &= 7
		if temp0 == 0
			Rand(temp0, 48)
			temp0 -= 24
			temp0 <<= 16
			temp0 += object.xpos
			Rand(temp1, 48)
			temp1 -= 24
			temp1 <<= 16
			temp1 += object.ypos
			CreateTempObject(TypeName[Explosion], 0, temp0, temp1)
			object[tempObjectPos].drawOrder = 5
			PlaySfx(SfxName[Explosion], false)
		end if
	end if

	if object.screenShake > 0
		object.screenShake--
		temp0 = object.screenShake
		temp0 &= 7
		if temp0 == 0
			screen.shakeX = 1
		end if
		temp0 = object.screenShake
		temp0 &= 3
		if temp0 == 0
			screen.shakeY = 2
		end if
	end if

	switch object.flame.state
	case 0
		object.flame.frame -= 4
		object.flame.frame ^= 1
		object.flame.frame += 4
		break

	case 1
		object.flame.timer += 2
		if object.flame.timer >= object.flame.animSpeed
			object.flame.timer = 0
			object.flame.frame -= 5
			object.flame.frame ^= 1
			object.flame.frame += 5
			if object.flame.animSpeed > 4
				object.flame.animSpeed--
			end if
		end if
		break

	case 2
		object.flame.timer += 2
		if object.flame.timer >= object.flame.animSpeed
			object.flame.timer = 0
			object.flame.frame -= 5
			object.flame.frame ^= 1
			object.flame.frame += 5
			if object.flame.animSpeed < 16
				object.flame.animSpeed++
				if object.flame.animSpeed == 16
					object.flame.frame = 5
					object.flame.state = 0
				end if
			end if
		end if
		break

	case 3
		object.flame.frame = 4
		break

	end switch
end event


event ObjectDraw
	temp0 = object.xpos
	if object.direction == FLIP_NONE
		temp0 += object.headOffset.x
	else
		temp0 -= object.headOffset.x
	end if
	temp1 = object.ypos
	temp1 += object.headOffset.y
	DrawSpriteFX(2, FX_ROTATE, temp0, temp1)
	
	DrawSpriteFX(3, FX_FLIP, object.xpos, object.ypos)
	DrawSpriteFX(object.flame.frame, FX_FLIP, object.xpos, object.ypos)
end event


event ObjectStartup
	CheckCurrentStageFolder("Zone12")
	if checkResult == true
		LoadSpriteSheet("DEZ/Objects.gif")
		
		// These first two are unused pre-rotated Head sprites
		SpriteFrame(12, -16, 23, 32, 487, 150)
		SpriteFrame(-20, -13, 54, 29, 430, 125)
		
		// In their place, a engine-rotated single Head sprite is used instead
		SpriteFrame(-32, -24, 71, 24, 414, 158)
		
		// Main Body
		SpriteFrame(-44, -36, 112, 72, 399, 183)
		
		// Flame Animation Sprites
		SpriteFrame(0, 0, 1, 1, 495, 106)
		SpriteFrame(48, 12, 16, 16, 495, 108)
		SpriteFrame(48, 12, 16, 24, 495, 83)
	else
		LoadSpriteSheet("MBZ/Objects.gif")
		
		SpriteFrame(12, -16, 23, 32, 999, 150)
		SpriteFrame(-20, -13, 54, 29, 942, 125)
		
		SpriteFrame(-32, -24, 71, 24, 926, 158)
		
		SpriteFrame(-44, -36, 112, 72, 911, 183)
		
		SpriteFrame(0, 0, 1, 1, 1007, 106)
		SpriteFrame(48, 12, 16, 16, 1007, 108)
		SpriteFrame(48, 12, 16, 24, 1007, 83)
	end if

	foreach (TypeName[Death Egg Robot], arrayPos0, ALL_ENTITIES)
		object[arrayPos0].rotation = 0x80
		object[arrayPos0].headOffset.x = 0xB0000
		object[arrayPos0].headOffset.y = -0x40000
	next
	
	// I sure hope you like tables, the compiler doesn't support putting tables in initial table declarations, so instead we have to manually place every value ourselves
	
	SetTableValue(DeathEggRobot_anim_sub_bend, 0, DeathEggRobot_anim_bendDown)
	
	SetTableValue(DeathEggRobot_anim_sub_bend, 0, DeathEggRobot_anim_getUp)
	
	SetTableValue(DeathEggRobot_anim_sub_bend, 0, DeathEggRobot_anim_land)
	
	SetTableValue(DeathEggRobot_anim_sub_jump, 0, DeathEggRobot_anim_jump)
	
	SetTableValue(DeathEggRobot_anim_sub_walk, 0, DeathEggRobot_anim_stepAhead)
	
	SetTableValue(DeathEggRobot_anim_sub_walk, 0, DeathEggRobot_anim_stepBack)
	
	SetTableValue(DeathEggRobot_bend_frame_1, 0, DeathEggRobot_anim_sub_bend)
	SetTableValue(DeathEggRobot_bend_frame_2, 1, DeathEggRobot_anim_sub_bend)
	SetTableValue(DeathEggRobot_bend_frame_3, 2, DeathEggRobot_anim_sub_bend)
	SetTableValue(DeathEggRobot_bend_frame_4, 3, DeathEggRobot_anim_sub_bend)
	SetTableValue(DeathEggRobot_bend_frame_5, 4, DeathEggRobot_anim_sub_bend)
	SetTableValue(DeathEggRobot_bend_frame_6, 5, DeathEggRobot_anim_sub_bend)
	SetTableValue(DeathEggRobot_bend_frame_7, 6, DeathEggRobot_anim_sub_bend)
	SetTableValue(DeathEggRobot_bend_frame_8, 7, DeathEggRobot_anim_sub_bend)
	SetTableValue(DeathEggRobot_bend_frame_9, 8, DeathEggRobot_anim_sub_bend)
	
	SetTableValue(DeathEggRobot_jump_frame_1, 0, DeathEggRobot_anim_sub_jump)
	SetTableValue(DeathEggRobot_jump_frame_2, 1, DeathEggRobot_anim_sub_jump)
	SetTableValue(DeathEggRobot_jump_frame_3, 2, DeathEggRobot_anim_sub_jump)
	
	SetTableValue(DeathEggRobot_walk_frame_1,  0,  DeathEggRobot_anim_sub_walk)
	SetTableValue(DeathEggRobot_walk_frame_2,  1,  DeathEggRobot_anim_sub_walk)
	SetTableValue(DeathEggRobot_walk_frame_3,  2,  DeathEggRobot_anim_sub_walk)
	SetTableValue(DeathEggRobot_walk_frame_4,  3,  DeathEggRobot_anim_sub_walk)
	SetTableValue(DeathEggRobot_walk_frame_5,  4,  DeathEggRobot_anim_sub_walk)
	SetTableValue(DeathEggRobot_walk_frame_6,  5,  DeathEggRobot_anim_sub_walk)
	SetTableValue(DeathEggRobot_walk_frame_7,  6,  DeathEggRobot_anim_sub_walk)
	SetTableValue(DeathEggRobot_walk_frame_8,  7,  DeathEggRobot_anim_sub_walk)
	SetTableValue(DeathEggRobot_walk_frame_9,  8,  DeathEggRobot_anim_sub_walk)
	SetTableValue(DeathEggRobot_walk_frame_10, 9,  DeathEggRobot_anim_sub_walk)
	SetTableValue(DeathEggRobot_walk_frame_11, 10, DeathEggRobot_anim_sub_walk)
	SetTableValue(DeathEggRobot_walk_frame_12, 11, DeathEggRobot_anim_sub_walk)
end event


// ========================
// Editor Events
// ========================

event RSDKEdit
	if editor.returnVariable == true
		switch editor.variableID
		case EDIT_VAR_PROPVAL // property value
			checkResult = object.propertyValue
			break
			
		case 0 // skipCutscene
			checkResult = object.propertyValue
			break
			
		end switch
	else
		switch editor.variableID
		case EDIT_VAR_PROPVAL // property value
			object.propertyValue = editor.variableValue
			break
			
		case 0 // skipCutscene
			object.propertyValue = editor.variableValue
			break
			
		end switch
	end if
end event


event RSDKDraw
	DrawSprite(0)
end event


event RSDKLoad
	CheckCurrentStageFolder("Zone12")
	if checkResult == true
		LoadSpriteSheet("DEZ/Objects.gif")
		SpriteFrame(-44, -36, 112, 72, 399, 183)
	else
		LoadSpriteSheet("MBZ/Objects.gif")
		SpriteFrame(-44, -36, 112, 72, 911, 183)
	end if

	AddEditorVariable("skipCutscene")
	SetActiveVariable("skipCutscene")
	AddEnumVariable("false", false) // Used in DEZ
	AddEnumVariable("true",  true)  // Used in MBZ & Boss Rush
end event
